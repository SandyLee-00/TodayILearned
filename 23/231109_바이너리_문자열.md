```cpp
// 23. 바이너리 데이터를 문자열로 변환하기

#include <string>
#include <sstream>
#include <iomanip>
#include <vector>
#include <array>
#include <assert.h>
#include <iostream>

// Iter로 돌면서 16진수 문자열로 변환
template <typename Iter>
std::string bytes_to_hexstr(Iter begin, Iter end, bool const uppercase = false)
{
	std::ostringstream oss;
	if (uppercase)
	{
		// 대문자로 출력
		oss.setf(std::ios_base::uppercase);
	}

	for (; begin != end; ++begin)
	{
		// 출력 hex로 설정, 2자리로 출력, 빈자리는 0으로 채움, begin 데이터 int로 변환
		oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(*begin);
	}

	// oss에 있는 문자열을 반환
	return oss.str();
}

// 컨테이너 C로 넣어서 실제 컨테이너의 begin(), end()를 호출
template <typename C>
std::string bytes_to_hexstr(C const& c, bool const uppercase = false)
{
	return bytes_to_hexstr(std::cbegin(c), std::cend(c), uppercase);
}

int main()
{
	// 테스트용 데이터
	std::vector<unsigned char> v{ 0xBA, 0xAD, 0xF0, 0x0D };
	std::array<unsigned char, 6> a{ { 1,2,3,4,5,6 } };
	unsigned char buf[5] = { 0x11, 0x22, 0x33, 0x44, 0x55 };

	// 대문자 결과 확인
	assert(bytes_to_hexstr(v, true) == "BAADF00D");
	assert(bytes_to_hexstr(a, true) == "010203040506");
	assert(bytes_to_hexstr(buf, true) == "1122334455");

	std::cout << bytes_to_hexstr(v, true) << std::endl;
	std::cout << bytes_to_hexstr(a, true) << std::endl;
	std::cout << bytes_to_hexstr(buf, true) << std::endl;

	assert(bytes_to_hexstr(v) == "baadf00d");
	assert(bytes_to_hexstr(a) == "010203040506");
	assert(bytes_to_hexstr(buf) == "1122334455");

	std::cout << bytes_to_hexstr(v) << std::endl;
	std::cout << bytes_to_hexstr(a) << std::endl;
	std::cout << bytes_to_hexstr(buf) << std::endl;

}
```

```cpp
// 24. 문자열을 바이너리 데이터로 변환하기

#include <string>
#include <sstream>
#include <iomanip>
#include <vector>
#include <array>
#include <assert.h>
#include <iostream>
#include <string_view>

unsigned char hexchar_to_int(char const ch)
{
	// char를 unsigned char 숫자 데이터로 변환
	if (ch >= '0' && ch <= '9')
	{
		return ch - '0';
	}
	if (ch >= 'A' && ch <= 'F')
	{
		return ch - 'A' + 10;
	}
	if (ch >= 'a' && ch <= 'f')
	{
		return ch - 'a' + 10;
	}
	// 0~F 사이의 문자가 아닌 경우 예외 
	throw std::invalid_argument("Invalid hexadecimal character");
}

// const string& -> string_view: substring 처리할 때 시간 빠르다
std::vector<unsigned char> hexstr_to_bytes(std::string_view str)
{
	std::vector<unsigned char> result;

	// 문자2개 -> (XXXX 0000 | XXXX) 로 변환
	for (size_t i = 0; i < str.size(); i += 2)
	{
		result.push_back(
			(hexchar_to_int(str[i]) << 4) | hexchar_to_int(str[i + 1]));
	}
	return result;
}

int main()
{
	std::vector<unsigned char> expected{ 0xBA, 0xAD, 0xF0, 0x0D, 0x42 };
	assert(hexstr_to_bytes("BAADF00D42") == expected);
	assert(hexstr_to_bytes("BaaDf00d42") == expected);
}
```

```cpp
// 2. 최대공약수 프로그램 구현하기

#include <iostream>

// 나머지 0 -> 배수 관계, 나눈 수 % 나머지 -> 자를 수 있는 공통 크기의 조각 찾기 
unsigned int gcd_recursive(unsigned int const a, unsigned int const b)
{
	return b == 0 ? a : gcd_recursive(b, a % b);
}

unsigned int gcd_iterative(unsigned int a, unsigned int b)
{
	while (b != 0)
	{
		unsigned int r = a % b;
		a = b;
		b = r;
	}
	return a;
}

int main()
{
	unsigned int a, b;
	std::cin >> a >> b;

	std::cout << "gcd recursive: " << gcd_recursive(a, b) << std::endl;

	std::cout << "gcd iterative: " << gcd_iterative(a, b) << std::endl;
}
```
