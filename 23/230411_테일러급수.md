### Series (급수)

수열의 각 항을 순서대로 더한다

---

### 테일러 급수

미분가능한 함수 → 여러번 미분해서 다항식의 합으로 비슷하게 만들었다

로그함수 : 정의역에서 무한대로 발산한다

### 테일러 정리

접선을 통해 함수를 근사하는 선형근사 (linear approximation) 를 일반화한 다항함수 형태이다

### 로그함수의 테일러근사

x축에 접하지 않고 x축을 교차하지 않는다 

→ 정의역에서 무한대로 발산한다

→ 함수값이 양의 방향으로 무한히 커지거나 작아진다

### 매클로린 급수

a = 0 일 때의 테일러 급수

### 멱급수

어떤 수를 자연수의 거듭제곱으로 계속해서 더한다

### 삼각함수의 테일러 근사

sin(x) = x - x^3/3! + x^5/5! - x^7/7!  …

cos(x) = 1 - x^2/2! + x^4/4! - x^6/6! …

### 테일러 급수의 정확도

정의에 따라 찾는 근사값보다 테일러 급수를 이용한 것이 정확도가 높은 이유? 

→ 테일러 급수는 무한항으로 이루어진다

### arcos

이동을 하기 위해 회전을 한다, 회전각을 구해야 한다

### 삼각법

삼각형의 각도에 따라서 변의 길이가 특정 비율을 가진다

### Trigonometric  삼각함수

삼각비의 정의역 예각에서 일반각으로 확장했다

테일러급수전개를 활용한 전개

다형성에 대해 설명해라

virtual 함수에 대해 설명해라

소멸자에 virtual을 쓰는 이유는 무엇인가

volatile 키워드에 대해 설명해라

인터페이스 추상 클래스 차이

스마트 포인터?

객체가 여러 형태를 가질 수 있다는 것이다 상속을 하면 부모 클래스의 기능을 가져온다. 이 때 사용하는 함수가 달라질 수 있다. 그래서 런타임에서 달라질 수 있다. 오버로딩에서도 객체는 다형성을 가질 수 있는데 이것은 컴파일 타임에서 갖는 다형성이다.

상속을 할 때 부모에서 이 내용은 오버라이딩을 할 수 있다고 표현하는 것이다 새롭게 내용을 쓰면 그렇게 작동한다.

소멸자는 delete로 사라지는 것이다. virtual은 가상함수로 하기 위해 붙인다. 소멸자는 생성자와 같이 객체가 사용되는 동안에 호출되고 사용이 끝나면 호출된다. 추측하는 내용은 오버라이딩을 하기 위해서 기본적으로 들어가는 것인가...?

volatile 전혀 모른다

인터페이스는 기능을 추가하는 라이브러리 같은 것이고 추상클래스는 프레임워크 같은 것이다 인터페이스를 추가하면 이런 더해서 기능을 가질 것이라고 기대한다. 추상클래스에서는 부모의 내용을 베이스로 또 다른 객체를 만들 수 있도록 한다.

GC를 하기 위해 만들어진 객체이다. 다른 곳에서 사용하기 위해 쓰고 있으면 메모리에서 지우지 말라고 카운팅을 한다. malloc과 같이 메모리 관리를 해야하는 부분을 프로그래머가 하지 않을 수 있도록 해준다.

모르는 부분 : 가상함수, 가상함수 테이블, 함수포인터, 객체의 생성과 소멸, volatile 키워드, smart pointer 구현, GC, 멀티쓰레드,
