### string_view

문자열에 대한 포인터 + 길이만 가져서 가볍다 

const char*처럼 포인터 받기 + const std::string& string 기능 하기 

```cpp
// 25. 문자열을 제목 형식으로 바꾸기

#include <string>
#include <cassert>
#include <sstream>
#include <cctype>

// std::string == std::basic_string<char>, std::wstring == std::basic_string<wchar_t>
template <class Elem>
using tstring = std::basic_string<Elem, std::char_traits<Elem>, std::allocator<Elem>>;

template <class Elem>
using tstringstream = std::basic_stringstream<Elem, std::char_traits<Elem>, std::allocator<Elem>>;

template <class Elem>
tstring<Elem> capitalize(tstring<Elem> const& text)
{
	tstringstream<Elem> result;

	bool newWord = true;
	for (auto const ch : text)
	{
		// 첫번째 -> 대문자 / 특수문자 || 스페이스면 다음 글자 대문자
		newWord = newWord || std::ispunct(ch) || std::isspace(ch);

		if (std::isalpha(ch) && newWord)
		{
			result << static_cast<Elem>(std::toupper(ch));
			newWord = false;
		}
		else if (std::isalpha(ch) && newWord == false)
		{
			result << static_cast<Elem>(std::tolower(ch));
		}
		else if(std::isalpha(ch) == false)
		{
			result << ch;
		}
	}
	return result.str();
}

int main()
{
	using namespace std::string_literals;

	std::string text = "cOnvert To UPPERS only first letter";
	std::string expected = "Convert To Uppers Only First Letter";

	assert(capitalize(text) == expected);

	assert(
		L"The C++ Challenger"s ==
		capitalize(L"the c++ challenger"s));

	assert(
		L"This Is An Example, Should Work!"s ==
		capitalize(L"THIS IS an ExamplE, should wORk!"s));
}
```

```cpp
// 26. 구획 문자로 나누어진 문자열 합치기

#include <string>
#include <cassert>
#include <sstream>
#include <cctype>
#include <vector>
#include <array>

template <typename Iter>
std::string join_strings(Iter begin, Iter end, char const* const separator)
{
	// output string stream
	std::ostringstream os;

	// copy: Iter begin, end -> os Iter로 copy
	// ostream_iterator: os에 대한 Iter를 만들어줌 separator로 분리
	
	// 마지막 문자열을 제외하고 모두 separator를 붙여줌
	std::copy(begin, end - 1, std::ostream_iterator<std::string>(os, separator));
	
	// 마지막 문자열은 separator를 붙이지 않음
	os << *(end - 1);

	return os.str();
}

// 컨테이너 넘겨서 해당하는 컨테이너의 begin end로 넘겨줌
template <typename C>
std::string join_strings(C const& c, char const* const separator)
{
	if (c.size() == 0)
	{
		return std::string{};
	}

	return join_strings(std::begin(c), std::end(c), separator);
}

int main()
{
	using namespace std::string_literals;

	std::vector<std::string> v1{ "this","is","an","example" };
	std::vector<std::string> v2{ "example" };
	std::vector<std::string> v3{ };

	assert(
		join_strings(v1, " ") == "this is an example"s);

	assert(
		join_strings(v2, " ") == "example"s);

	assert(
		join_strings(v3, " ") == ""s);

	std::array<std::string, 4> a1{ {"this","is","an","example"} };
	std::array<std::string, 1> a2{ {"example"} };
	std::array<std::string, 0> a3{};

	assert(
		join_strings(a1, " ") == "this is an example"s);

	assert(
		join_strings(a2, " ") == "example"s);

	assert(
		join_strings(a3, " ") == ""s);
}
```

```cpp
// 27. 구획 문자 리스트를 바탕으로 문자열을 토큰으로 분리하기

#include <string>
#include <cassert>
#include <sstream>
#include <cctype>
#include <vector>

template <class Elem>
using tstring = std::basic_string<Elem, std::char_traits<Elem>, std::allocator<Elem>>;

// stringstream: string 객체를 stream처럼 사용할 수 있게 해준다
// stream: 데이터를 입출력하는데 사용되는 객체 InputStream, OutputStream
template <class Elem>
using tstringstream = std::basic_stringstream<Elem, std::char_traits<Elem>, std::allocator<Elem>>;

// delimiter 하나
template<typename Elem>
inline std::vector<tstring<Elem>> split(tstring<Elem> text, Elem const delimiter)
{
	auto sstr = tstringstream<Elem>{ text };
	auto tokens = std::vector<tstring<Elem>>{};
	auto token = tstring<Elem>{};

	// getline: stringstream에 있는 내용을 delimiter를 기준으로 token으로 나눈다
	while (std::getline(sstr, token, delimiter))
	{
		if (!token.empty())
		{
			tokens.push_back(token);
		}
	}
	return tokens;
}

// delimiter 여러개
template<typename Elem>
inline std::vector<tstring<Elem>> split(tstring<Elem> text, tstring<Elem> const& delimiters)
{
	auto tokens = std::vector<tstring<Elem>>{};

	size_t pos, prev_pos = 0;

	// find_first_of: delimiters에 있는 문자가 text에서 처음으로 나오는 위치를 반환
	// prev_pos
	// string::npos: 문자열의 끝을 의미하는 상수 size_t max값 -1

	// prev_pos 이상부터 delimiters에 있는 문자가 처음으로 나오는 위치를 찾는다
	while ((pos = text.find_first_of(delimiters, prev_pos)) != std::string::npos)
	{
		// prev_pos부터 pos - prev_pos 길이만큼의 문자열을 tokens에 추가
		if (pos > prev_pos)
		{
			tokens.push_back(text.substr(prev_pos, pos - prev_pos));
		}

		// pos + 1로 다음 문자로 넘어가기
		prev_pos = pos + 1;
	}

	// 마지막 token 처리
	if (prev_pos < text.length())
	{
		tokens.push_back(text.substr(prev_pos, std::string::npos));
	}

	return tokens;
}

int main()
{
	// string_literals: ""s 쓸 수 있게 한다 
	using namespace std::string_literals;

	std::vector<std::string> expected{ "this", "is", "a", "sample" };

	assert(expected == split("this is a sample"s, ' '));
	assert(expected == split("this,is a.sample!!"s, ",.! "s));
	
}
```

```cpp
// 이중 우선순위 큐
/*
priority queue 2개 쓰기
Min max
I 둘 다 넣기 size++
빼기 min 빼고 mincnt— 
빼기 size - mincnt -maxcnt > 0이면 가능

출력
size - mincnt -maxcnt > 0
min max front
*/
```
