### reference_wrapper

참조를 받지 않는 벡터에 참조 넣기 → 객체로 포장해서 넣기 

### 스레드 생성해야 하는 경우 :

유저가 프로세스가 멈추었다고 느끼지 않게 백그라운드에서 실행해야 할 때 별도의 스레드로 분리한다.

Socket listener : 네트워크 관련 IO를 하는 부분은 다른 스레드를 쓴다. 

Loading Resource : 텍스쳐, 3D모델, 사운드 등 크기가 큰 것을 올릴 때 쓴다. 

Rendering : update → render을 분리한다. 병렬적으로 처리해서 render는 이전 update의 데이터를 쓴다. 1프레임 전을 render 한다.

Game Thread : Poll input / Update AI / Animation / Physics

Render Thread : Ready structure / Cull Objects / Forward Pass / Postfix

### 스레드 생성하지 말아야 하는 경우 :

여러 스레드를 이용해 하나의 사용자 인터페이스를 만들 필요가 없다. 사용자는 한 명이고 한 번에 하나의 입력이 들어온다. 

concurrency : 서로 다른 시스템들이 영향을 주고받고 선형적으로 쭉 진행되어야 하는 부분에서는 오히려 맞추는데 시간이 걸린다. 

너무 많은 스레드 : 루프를 나눌 때 많은 파이프 라인으로 나눠서 기능별로 스레드로 분리한다. 파이프라인으로 많은 단계를 1프레임씩 늦춰서 하면 입력이 밀리는 느낌을 받을 수 있어서 update / render의 단계로만 분리하는 것이 나은 편이다. 

2D : 스프라이트로 그리는 간단한 게임이면 싱글 스레드로 한다. 

### 스레드 종료 방법

1 스레드 함수 반환 

2 스레드 함수 내에서 ExitThread()

3 프로세스에서 TerminateThread()

4 스레드가 포함된 프로세스 종료 

1번을 추천한다. 스레드 함수가 반환되면 수행되는 작업이 있기 때문이다.

Object destructor : 갖고있던 오브젝트 리소스를 해제해준다

스택 메모리 : 함수를 부르면서 스택으로 사용한 메모리를 반환한다.

스레드 종료 코드 : 종료 코드가 반환 값으로 설정 → 스레드 커널 오브젝트에 저장

사용 카운트 : 스레드 커널 오브젝트 사용 카운트가 감소된다. 

2 ExitThread 문제점 :

Object destructor (X)

스택 메모리(O)

스레드 종료 코드 (O)

3 TerminateThread 문제점

스택 메모리(X)

스레드 종료 코드 (O)

사용 카운트(O)

4 프로세스 종료 문제점

Object destructor (X) 하지만 사용하던 메모리 정리하거나 저장 안하고 다 날린다.

스택 메모리(O)
