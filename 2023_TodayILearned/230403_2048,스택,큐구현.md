### 2048 만들기

각 숫자 블럭 모델링하기

2빨 4주 8노 16파 32남 64보 128핑 256하 512은 1024금 2048투명

블록사이즈, 전체 판 사이즈 정하기

키보드 상하좌우 하면 전체 회전하도록 하기

마우스로 드래그 해서 회전, 때면 그 방향으로 회전하기

리셋버튼, 멈추기 버튼, 플레이 타임 기록

클리어하면 점수 기록 판 보이기

---

1. 스택
a. char 자료형을 입/출력하는 스택을 구현한다.
b. 스택의 상태에 따른 예외처리할 것.
c. (심화)스택의 사이즈를 변경할 수 있도록 할 것.
2. 큐
a. char 자료형을 입/출력하는 큐를 구현한다.
b. 큐의 상태에 따른 예외처리 할 것.
c. 언제든 큐의 크기만큼 사용 가능할 것. (환형 큐 등)
d. (심화)큐의 사이즈를 변경할 수 있도록 할 것.

```cpp
/// 스택
/// 함수, 배열, 전역변수
/// 인덱스 예외처리, 타입 1개로 고정
/// 2023.03.01 Sandy

// 외부 라이브러리 헤더 포함
#include <iostream>
using namespace std;

int g_Stack[10];
int g_Index = 0; // 값을 넣을 수 있는 곳을 가리킨다

// 스택 초기화
void ResetStack()
{
	for (int i = 0; i < 10; i++) 
	{
		g_Stack[i] = -1;
	}

	return;
}

/// <summary>
/// 스택의 내용을 출력한다
/// </summary>
void PrintStack()
{

	for (int i = 0; i < 10; i++)
	{
		if (g_Stack[i] == -1)
		{
			cout << "[ ]" << " ";
		}
		else
			cout << "[" << g_Stack[i] << "]" << " ";
	}
	cout << "\n\n";

	return;
}

/// <summary>
/// 데이터 하나를 스택에 넣는다
/// </summary>
/// <param name="data"></param>
void PushDataToStack(int data)
{
	if (10 <= g_Index)
	{
		cout << "스택이 가득 찼습니다\n";
		return;
	}
	// 스택에 g_Index 이용해서 data 넣기
	g_Stack[g_Index] = data;
	
	g_Index++;

	PrintStack();
	return;
}

int PopDataFromStack()
{
	if (g_Index <= 0)
	{
		cout << "스택이 비었습니다\n\n";
		return 0;
	}

	int _result = 0;
	// idx 스택의 탑, -1 해서 그 데이터 가져오기
	_result = g_Stack[g_Index-1];
	g_Stack[g_Index-1] = -1;

	g_Index--;
	cout << "스택에서 " << _result << "뺐습니다\n\n";

	PrintStack();

	return _result;
}

int main() 
{
	ResetStack();
	PushDataToStack(10);

	PopDataFromStack();
	PopDataFromStack();
	PopDataFromStack();

	return 0;
}
```

```cpp
/// 큐_v1
/// struct로 my_queue 선언
/// 할 일 : templete, circular
/// 2023.03.01 Sandy

// 외부 라이브러리 헤더 포함
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
using namespace std;

/*
https://en.cppreference.com/w/cpp/container/queue
https://www.boost.org/doc/libs/1_81_0/doc/html/boost/circular_buffer_sp_idm5277.html

Element access
front();	// Access next element
back();		// Access last element

Capacity
empty();	// checks whether the underlying container is empty
size();		// returns the number of elements

Modifiers
push();		// inserts element at the end
pop();		// removes the first element
*/

#define MAX_QUEUE_SIZE 10
typedef struct
{
	int data[MAX_QUEUE_SIZE];
	int front;
	int rear;
}my_queue;

void init_queue(my_queue* q);

int front(my_queue* q);
int back(my_queue* q);

bool empty(my_queue* q);
int size(my_queue* q);

void push(my_queue* q, int data);
int pop_int(my_queue* q);
void pop_void(my_queue* q);

bool is_full(my_queue* q);
void print_queue(my_queue* q);

void init_queue(my_queue* q)
{
	q->front = 0;
	q->rear = 0;
	return;
}

int front(my_queue* q)
{// rear-1 idx에서 맨 앞 데이터 보기
	int ret;
	if (empty(q))
	{
		cout << "큐가 비었다\n";
		return -1;
	}
	ret = q->data[q->rear-1];
	return ret;
}

int back(my_queue* q)
{// front idx에서 맨 뒤 데이터 보기
	int ret;
	if (empty(q))
	{
		cout << "큐가 비었다\n";
		return -1;
	}
	ret = q->data[q->front];
	print_queue(q);
	return ret;
}

bool empty(my_queue* q)
{// front == rear
	bool ret;
	ret = q->front == q->rear;
	return ret;
}

int size(my_queue* q)
{// rear - front = size
	int ret;
	ret = q->rear - q->front;
	return ret;
}

void push(my_queue* q, int val)
{// rear idx에다가 val 넣기, rear++ 해서 idx 이동하기
	if (is_full(q))
	{
		cout << "큐가 찼다\n";
		return;
	}
	q->data[q->rear] = val;
	q->rear++;

	print_queue(q);
	return;
}

int pop_int(my_queue* q)
{// front idx에서 데이터 빼기, front++ 해서 idx 이동하기
	int ret;
	if (empty(q))
	{
		cout << "큐가 비었다\n";
		return -1;
	}
	ret = q->data[q->front];
	q->front++;

	print_queue(q);
	return ret;
}

void pop_void(my_queue* q)
{// front++ 해서 idx 이동하기
	if (empty(q))
	{
		cout << "큐가 비었다\n";
		return;
	}
	q->front++;
	print_queue(q);
	return;
}

bool is_full(my_queue* q)
{
	bool ret;
	ret = q->rear >= MAX_QUEUE_SIZE;
	return ret;
}

void print_queue(my_queue* q)
{
	cout << "\nfrontIdx : " << q->front << ", rearIdx : " << q->rear << "\n";
	for (int i = 0; i < MAX_QUEUE_SIZE; i++)
	{
		if (i < q->front || i >= q->rear)
			cout << "[ ] ";
		else
			cout << "[" << q->data[i] << "] ";
	}
	cout << "\n\n";
}

int main()
{
	my_queue q;
	init_queue(&q);
	print_queue(&q);
	push(&q, 0);
	push(&q, 1);
	push(&q, 2);
	push(&q, 3);
	push(&q, 4);
	push(&q, 5);
	push(&q, 6);
	push(&q, 7);
	pop_void(&q);
	int frontVal = front(&q);
	cout << "frontVal : " << frontVal << "\n";
	int backVal = back(&q);
	cout << "backVal : " << backVal << "\n";
	pop_int(&q);
	pop_int(&q);
	cout << "size : " << size(&q) << "\n";
	cout << "is empty : " << empty(&q) << "\n";
	pop_int(&q);
	cout << "is full : " << is_full(&q) << "\n";
	push(&q, 6);
	push(&q, 6);
	push(&q, 6);
	push(&q, 6);

	cout << "is full : " << is_full(&q) << "\n";

	return 0;
	
}
```

### Doxygen

설명서 대신 문서 형태로 만들어준다
