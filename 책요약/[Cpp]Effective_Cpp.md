### 1. C++는 멀티 패러다임 언어이다

### 2. #define보다 const, enum, inline을 사용하자

### 3. const를 사용하자

### 4. 객체를 사용하기 전에 그 객체를 초기화 하자

---

### 5. 컴파일러는 default constructor, destructor, copy, move sematics를 자동으로 만든다

### 6. 컴파일러가 만들어낸 함수가 필요 없으면 private으로 막자

### 7. Polymorphic한 Base 클래스에서 destructor를 virtual로 선언하자

파생 클래스의 객체가 파괴될 때 올바른 소멸자가 호출되어 메모리 누수를 방지한다. 

### 8. destructor는 예외를 던지면 안된다

### 9. 객체 생성 및 소멸 과정 중에는 virtual 함수를 호출하지 말자

derived 클래스의 멤버가 아직 초기화되지 않았거나 이미 파괴되었을 수 있기 때문이다.

### 10. operator=는 *this의 reference를 반환하게 하자

### 11. operator=에서는 자기대입에 대한 처리하자

### 12. copy constructor와 operator=는 따로 구현하자

---

### 13. RAII인 shared_ptr을 써서 자원관리하자

### 14. RAII copy에 대해 알고있자

RAII 객체를 복사할 때, 자원의 소유권이 공유될 수 있다.

### 15. RAII 클래스에서 자원 얻을 수 있게 API에게 열어주자

자원을 획득할 수 있는 공개적인 인터페이스를 제공해야 한다

### 16. new[]로 할당된 배열은 delete[]로, new로 할당된 개별 객체는 delete로 해제하기

메모리 해제 동작이 다르다

### 17. new로 생성한 객체를 스마트 포인터에 저장하는 코드는 한 문장으로 만들자

new로 생성한 객체를 스마트 포인터에 저장할 때는 동적으로 할당된 메모리를 해제해야 한다

---

### 18. 인터페이스 설계는 제대로 쓰기엔 쉽게, 잘못 쓰기엔 어렵게 하자

### 19. 클래스 설계할 때 구조, 구현 생각하자

### 20. pass by 'value'보다는 pass by ‘const 참조’ 방식이 copy가 없다

### 21. 함수에서 지역변수, 임시객체를 반환해야 할 경우에 reference를 반환하면 안된다

### 22. private 영역에 변수를 선언하자

### 23. 멤버 함수보다는 비멤버 비프렌드 함수 사용하자

클래스의 캡슐화를 유지하고 외부에서 클래스의 내부 데이터에 접근을 제한한다

### 24. 비멤버 함수에서 타입변환을 하자

클래스의 캡슐화를 유지하고 외부에서 클래스의 내부 표현에 대한 의존성을 제거하

### 25. swap이 느리면 만들자

---

### 26. 변수 정의 나중에 해서 constructor, destructor 호출 줄이자

### 27. dynamic_cast 느리다

RTTI 사용해서 작동하기 때문이다. 

### 28. 내부에서 사용하는 객체에 대한 ‘reference, pointer, iterator’ 반환 피하자

해당 객체의 내부 구현을 외부로 노출시키는 것과 같다. 

### 29. 예외가 발생해도 메모리 누수나 데이터 손실 처리하자

### 30. inline 이해하자

함수 호출 오버헤드를 줄이기 위해 컴파일러가 해당 함수의 코드를 호출 지점에 직접 삽입하는 것이다. 

### 31. 파일 사이의 컴파일 의존성을 최대로 줄이자

헤더 파일의 포함을 최소화하고 전방 선언과 인터페이스 추상화를 통해 의존성을 최대한 줄인다. 전방 선언을 사용하여 순환 의존성을 해결한다 

---

### 32. public 상속은 "is-a"관계이다

### 33. 상속된 이름을 숨기지말자

상속된 이름을 명시적으로 숨기는 대신, 다른 이름을 선택하거나 범위 지정 연산자를 사용하여 이름 충돌을 해결해야 한다 

### 34. =0 과 상속은 다르다

순수 가상 함수는 파생 클래스에서 반드시 재정의해야 하는 함수로, 기본 구현이 없다. 

### 35. virtual 함수 대신 템플릿 메타, 함수 포인터, strategy pattern, function object 를 쓸 수 있다

### 36. 상속받은 non-virtual 함수를 derived 클래스에서 override 하지 말자

### 37. 상속받은 default 매개변수값은 override 하지 말자

### 38. composition으로 is-implemented-in-terms-of 관계를 나타낸다

### 39. private 상속은 **is-implemented-in-terms-of 이다**

파생 클래스가 부모 클래스의 특성과 동작을 재사용하고, 그것들을 내부적으로 사용하거나 수정하기 위해 사용된다. 

### 40. 다중 상속 하기 전에 필요한지 생각하자

---

### 41. template은 암시적 인터페이스를 지원하고 컴파일타임 다형성을 만든다

템플릿이 받아들이는 타입이 특정한 연산이나 메서드를 지원하도록 요구한다. 컴파일되는 시점에서 여러 타입에 대해 동일한 코드를 생성한다. 

### 42. typename은 **타입 이름이라는 것을 알려준다**

### 43. derived클래스 template에서 base클래스 template에 이름 접근할 수 있다

### 44. 템플릿 매개변수에 관련없는 코드는 템플릿에서 분리하자

### 45. 멤버 함수 템플릿은 특정한 타입이 아닌, 다양한 타입의 객체를 다루는 함수를 작성한다

### 46. 클래스와 밀접하게 관련된 타입 변환을 정의할 때는 클래스 템플릿 안에 비멤버 함수를 정의한다

### 47. traits 클래스는 템플릿을 사용하여 타입에 대한 정보를 제공한다

### 48. 템플릿 메타프로그래밍은 컴파일 타임에 코드를 생성하고 실행한다

---

### 49. new handler는 메모리 할당 실패를 처리한다

### 50. new 및 delete를 바꿔서 메모리 관리 동작을 구현한다

### 51. new 및 delete를 구현할 때

메모리 할당 및 해제 동작은 상호 일치해야 하므로 new와 delete를 함께 구현한다

### 52. **placement** new를 만들면 **placement** delete도 만들자

특정한 메모리 위치에 객체를 생성하고 해당 메모리 위치에서 객체를 파괴하고 할당된 메모리를 해제

---

### 53. 컴파일러 경고 확인하자

### 54. 표준라이브러리 잘 쓰자

### 55. Boost 라이브러리 잘 쓰자